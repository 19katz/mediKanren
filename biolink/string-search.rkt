#lang racket/base
(provide
  string/searchable
  suffix:corpus->index
  suffix:corpus-find*
  string:corpus->index
  string:corpus-find*)
(require
  racket/list
  racket/string
  racket/vector)

(define sort-threshold 500000)
(define (length<threshold? vs)
  (let loop ((vs vs) (remaining sort-threshold))
    (cond ((null? vs)      #t)
          ((= 0 remaining) #f)
          (else (loop (cdr vs) (- remaining 1))))))

(define (msd-radix-sort vs len ref d<? v<?)
  ;; If this simple version isn't fast enough, here are possible improvements:
  ;; * faster bucket identification
  ;;   * allocate a contiguous digit range rather than a minimal set
  ;; * allocate vector buffers instead of using intermediate lists
  (define out (make-vector (length vs)))
  (define out-pos 0)
  (define (output! vs) (for ((v vs))
                            (vector-set! out out-pos v)
                            (set! out-pos (+ 1 out-pos))))
  ;(define (bucket vs i)
    ;(define digit=>bucket (hash))
    ;(for ((v vs))
         ;(cond ((<= (len v) i) (vector-set! out out-pos v)
                               ;(set! out-pos (+ 1 out-pos)))
               ;(else (set! digit=>bucket
                       ;(hash-update digit=>bucket (ref v i)
                                    ;(lambda (b) (cons v b)) '())))))
    ;(for ((d (sort (hash-keys digit=>bucket) d<?)))
         ;(define found (reverse (hash-ref digit=>bucket d)))
         ;(if (length<threshold? found)
           ;(output! (sort found v<?))
           ;(bucket found (+ i 1)))))
  ;(bucket vs 0)
  (output! (sort vs v<?))
  out)

;(define char-digit-len (+ (- (char->integer #\z) (char->integer #\A)) 1))

;(define (msd-radix-sort vs dlen len ref v<?)
  ;(define out (make-vector (length vs)))
  ;(define out-pos 0)
  ;(define (output! vs) (for ((v vs))
                            ;(vector-set! out out-pos v)
                            ;(set! out-pos (+ 1 out-pos))))
  ;(define (bucket vs i)
    ;;; PERF: only reverse once at the end, and only when i is even.
    ;;; Or don't worry about stable sorting, and just don't reverse.
    ;(define below '())
    ;(define above '())
    ;(define buckets (make-vector dlen '()))
    ;(for ((v vs))
         ;(cond ((<= (len v) i)
                ;(vector-set! out out-pos v)
                ;(set! out-pos (+ 1 out-pos)))
               ;(else (define digit (ref v i))
                     ;(cond ((<  digit 0)    (set! below (cons v below)))
                           ;((>= digit dlen) (set! above (cons v above)))
                           ;(else (vector-set!
                                   ;buckets digit
                                   ;(cons v (vector-ref buckets digit))))))))
    ;(output! (sort (reverse below) v<?))
    ;(for ((b buckets)) (unless (null? b) (bucket (reverse b) (+ i 1))))
    ;;(for ((b buckets)) (unless (null? b) (loop (reverse b) (+ i 1))))
    ;(output! (sort (reverse above) v<?)))
  ;;(define (loop vs i) (if (length<threshold? vs)
                        ;;(output! (sort vs v<?))
                        ;;(bucket vs i)))
  ;;(loop vs 0)
  ;(bucket vs 0)
  ;out)

(define (nlist-intersection nlists)
  (let loop ((i** (map (lambda (nlist) (sort nlist <)) nlists)))
    (cond ((ormap null? i**) '())
          (else (define i0* (map car i**))
                (define next (apply max i0*))
                (if (andmap (lambda (i) (= i next)) i0*)
                  (cons next (loop (map cdr i**)))
                  (loop (map (lambda (i*) (dropf i* (lambda (i) (< i next))))
                             i**)))))))

(define i0              (char->integer #\0))
(define i9              (char->integer #\9))
(define iA              (char->integer #\A))
(define iZ              (char->integer #\Z))
(define (searchable? c) (and (<= i0 c) (<= c iZ) (or (<= c i9) (<= iA c))))
(define (string/searchable s)
  (define cs (map char->integer (string->list (string-upcase s))))
  (list->string (map integer->char (filter searchable? cs))))
(define (suffix->string corpus s)
  (substring (vector-ref corpus (car s)) (cdr s)))
(define (suffix-string-ref corpus s i)
  (string-ref (vector-ref corpus (car s)) (+ (cdr s) i)))
(define (string<?/suffixes a ai b bi)
  (define alen (- (string-length a) ai))
  (define blen (- (string-length b) bi))
  (let loop ((k (min alen blen)) (ai ai) (bi bi))
    (cond ((= k 0)                                      (< alen blen))
          ((char<? (string-ref a ai) (string-ref b bi)) #t)
          ((char>? (string-ref a ai) (string-ref b bi)) #f)
          (else (loop (- k 1) (+ ai 1) (+ bi 1))))))
(define (suffix<?/corpus corpus a b)
  (string<?/suffixes (vector-ref corpus (car a)) (cdr a)
                     (vector-ref corpus (car b)) (cdr b)))

(define (suffix:corpus->index corpus)
  (define suffixes
    (foldl (lambda (i all)
             (foldl (lambda (j all) (cons (cons i j) all))
                    all (range (string-length (vector-ref corpus i)))))
           '() (range (vector-length corpus))))
  (define (suffix<? a b)    (suffix<?/corpus corpus a b))
  (define (suffix-length s) (string-length (suffix->string corpus s)))
  (define (suffix-ref s i)  (suffix-string-ref corpus s i))
  ;(define (suffix-ref s i)
    ;(- (char->integer (suffix-string-ref corpus s i))
       ;(char->integer #\A)))
  ;(msd-radix-sort suffixes char-digit-len suffix-length suffix-ref suffix<?)
  (msd-radix-sort suffixes suffix-length suffix-ref char<? suffix<?))

(define (suffix:corpus-find corpus index str)
  (define needle (string/searchable str))
  (define (compare si needle)
    (define hay (suffix->string corpus (vector-ref index si)))
    (cond ((string-prefix? hay needle) 0)
          ((string<? hay needle)      -1)
          (else                        1)))
  ;; Find a point in the desired range...
  (let find-range ((start 0) (end (vector-length index)))
    (cond ((< start end)
           (define mid (+ start (quotient (- end start) 2)))
           (case (compare mid needle)
             ((-1) (find-range (+ 1 mid) end))
             (( 1) (find-range start mid))
             (( 0) ;; ... then find the start and end of that range.
              (define rstart
                (let loop ((start start) (end mid))
                  (cond ((< start end)
                         (define mid (+ start (quotient (- end start) 2)))
                         (case (compare mid needle)
                           ((-1) (loop (+ 1 mid) end))
                           (( 0) (loop start mid))
                           (else (error "rstart: this shouldn't happen."))))
                        (else end))))
              (define rend
                (let loop ((start (+ 1 mid)) (end end))
                  (cond ((< start end)
                         (define mid (+ start (quotient (- end start) 2)))
                         (case (compare mid needle)
                           ((1) (loop start mid))
                           ((0) (loop (+ 1 mid) end))
                           (else (error "rend: this shouldn't happen."))))
                        (else end))))
              (remove-duplicates (map (lambda (i) (car (vector-ref index i)))
                                      (range rstart rend))))))
          (else '()))))

(define (suffix:corpus-find* corpus index str*)
  (nlist-intersection
    (map (lambda (s) (suffix:corpus-find corpus index s)) str*)))

(define (string:corpus->index corpus)
  (define ixs (range (vector-length corpus)))
  (define (ix<? a b) (string<? (vector-ref corpus a) (vector-ref corpus b)))
  (define (ix-length ix) (string-length (vector-ref corpus ix)))
  (define (ix-ref ix i)  (string-ref (vector-ref corpus ix) i))
  ;(define (ix-ref ix i)
    ;(- (char->integer (string-ref (vector-ref corpus ix) i))
       ;(char->integer #\A)))
  ;(msd-radix-sort ixs char-digit-len ix-length ix-ref ix<?)
  (msd-radix-sort ixs ix-length ix-ref char<? ix<?))

(define (string:corpus-find corpus index needle)
  (define (compare si needle)
    (define hay (vector-ref corpus (vector-ref index si)))
    (cond ((string=? hay needle)  0)
          ((string<? hay needle) -1)
          (else                   1)))
  ;; Find a point in the desired range...
  (let find-range ((start 0) (end (vector-length index)))
    (cond ((< start end)
           (define mid (+ start (quotient (- end start) 2)))
           (case (compare mid needle)
             ((-1) (find-range (+ 1 mid) end))
             (( 1) (find-range start mid))
             (( 0) ;; ... then find the start and end of that range.
              (define rstart
                (let loop ((start start) (end mid))
                  (cond ((< start end)
                         (define mid (+ start (quotient (- end start) 2)))
                         (case (compare mid needle)
                           ((-1) (loop (+ 1 mid) end))
                           (( 0) (loop start mid))
                           (else (error "rstart: this shouldn't happen."))))
                        (else end))))
              (define rend
                (let loop ((start (+ 1 mid)) (end end))
                  (cond ((< start end)
                         (define mid (+ start (quotient (- end start) 2)))
                         (case (compare mid needle)
                           ((1) (loop start mid))
                           ((0) (loop (+ 1 mid) end))
                           (else (error "rend: this shouldn't happen."))))
                        (else end))))
              (remove-duplicates (map (lambda (i) (vector-ref index i))
                                      (range rstart rend))))))
          (else '()))))

(define (string:corpus-find* corpus index str*)
  (remove-duplicates
    (sort (append* (map (lambda (s) (string:corpus-find corpus index s)) str*))
          <)))
